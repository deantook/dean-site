import{_ as e}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as a,c as r,d as i}from"./app.1a439a22.js";const t={},h=i('<h1 id="缓存的使用" tabindex="-1"><a class="header-anchor" href="#缓存的使用" aria-hidden="true">#</a> 缓存的使用</h1><p>像大部分组件一样，在提供一系列便利性的同时，使用缓存也带来了一定的问题。</p><ul><li>增加系统复杂度</li><li>提高运维成本</li><li>引出数据一致性问题</li></ul><h2 id="缓存的读写策略" tabindex="-1"><a class="header-anchor" href="#缓存的读写策略" aria-hidden="true">#</a> 缓存的读写策略</h2><p>对于不同的业务场景，需要慎重考虑缓存的读写策略。尤其是在并发的情况下，不合适的读写策略会导致数据不一致的情况。</p><h3 id="cache-aside-pattern" tabindex="-1"><a class="header-anchor" href="#cache-aside-pattern" aria-hidden="true">#</a> Cache Aside Pattern</h3><p>Cache Aside Pattern 即旁路缓存策略，是最经典的读写策略：</p><ul><li>先读取</li></ul><h2 id="使用多级缓存来提升服务性能" tabindex="-1"><a class="header-anchor" href="#使用多级缓存来提升服务性能" aria-hidden="true">#</a> 使用多级缓存来提升服务性能</h2>',9),d=[h];function c(n,s){return a(),r("div",null,d)}const _=e(t,[["render",c],["__file","缓存的使用.html.vue"]]);export{_ as default};
