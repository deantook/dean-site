import{_ as e}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as i,c as d,d as s}from"./app.7cdf671b.js";const c={},a=s(`<h1 id="bigkey" tabindex="-1"><a class="header-anchor" href="#bigkey" aria-hidden="true">#</a> BigKey</h1><h2 id="morekey" tabindex="-1"><a class="header-anchor" href="#morekey" aria-hidden="true">#</a> MoreKey</h2><p>生产上限制keys*/flushdb/flushall等危险命令以防止误删误用</p><p>通过配置设置禁用这些命令,redis.conf在SECURITY这一项中</p><p>Redis中的<code>SCAN</code>命令可以用来迭代遍历所有的key，因为在Redis中所有的key都保存在一个大的哈希表中，而这个哈希表被分成了很多小的桶（buckets），所以直接遍历哈希表是非常慢的，特别是当Redis中有很多key的时候。</p><p><code>SCAN</code>命令的作用就是通过游标（cursor）来逐步迭代遍历整个Redis中的所有key，避免了一次性遍历所有key的性能问题。</p><p><code>SCAN</code>命令的基本语法如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>cssCopy code
SCAN cursor [MATCH pattern] [COUNT count]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>其中<code>cursor</code>参数是一个用于记录迭代状态的游标，用户每次调用<code>SCAN</code>命令时都需要提供这个游标。<code>MATCH</code>参数用于指定要匹配的key的模式，只有符合这个模式的key才会被返回。<code>COUNT</code>参数用于指定每次迭代返回的最大key数量。</p><p><code>SCAN</code>命令返回的是一个包含两个元素的数组，第一个元素是下一个迭代时要使用的游标，第二个元素是本次迭代返回的key列表。由于Redis的key空间是动态的，所以<code>SCAN</code>命令返回的key列表可能包含重复的key，用户需要根据自己的需要进行去重。</p><p>需要注意的是，由于<code>SCAN</code>命令是基于游标的迭代方式，所以在一次完整的迭代过程中，Redis可能会同时对同一个key进行多次访问，因此在使用<code>SCAN</code>命令时需要格外注意数据的一致性。</p><h2 id="bigkey-1" tabindex="-1"><a class="header-anchor" href="#bigkey-1" aria-hidden="true">#</a> BigKey</h2><h3 id="多大算大" tabindex="-1"><a class="header-anchor" href="#多大算大" aria-hidden="true">#</a> 多大算大？</h3><p>在Redis中，没有一个固定的大小来定义什么是“bigkey”，因为这取决于你的Redis实例的配置和机器的硬件资源。但通常，如果一个key的value比较大，或者一个集合类型的key中元素数量比较多，那么就可能会被认为是“bigkey”，因为它们可能会占用大量的内存，导致Redis的性能下降。一般来说，建议一个key的value大小控制在10KB以内，一个集合类型的key中元素数量控制在5000以内，这样可以保证Redis的性能和稳定性。当然，具体的数值还需要结合实际情况来确定。</p><h3 id="带来的问题" tabindex="-1"><a class="header-anchor" href="#带来的问题" aria-hidden="true">#</a> 带来的问题</h3><p>BigKey会带来以下问题：</p><ol><li>内存占用问题：BigKey占用的内存资源很大，这会导致Redis服务器的性能受到限制，甚至可能会导致服务器崩溃。</li><li>读写性能问题：当一个Key的值很大时，读写这个Key的性能会受到影响，这会降低Redis服务器的整体性能。</li><li>备份和恢复问题：当需要备份和恢复Redis服务器时，BigKey会增加备份和恢复的时间和复杂性，这会降低Redis服务器的可靠性和可维护性。</li></ol><p>因此，在设计Redis应用程序时，应尽可能避免使用BigKey。可以将大的数据拆分成多个小的数据存储，或者使用Redis提供的各种数据结构，如Hash、List、Set、Zset等，来优化数据存储和读写性能。</p><h3 id="如何发现" tabindex="-1"><a class="header-anchor" href="#如何发现" aria-hidden="true">#</a> 如何发现</h3><p>发现bigkey可以通过Redis自带的命令进行，常用的命令包括：</p><ol><li><code>redis-cli --bigkeys</code>：通过redis-cli工具直接查找bigkey，该命令会列出所有大小超过阈值的bigkey。</li><li><code>SCAN</code>命令：使用SCAN命令遍历所有的key，针对每个key再使用<code>DEBUG OBJECT key</code>命令查看其内存占用情况，通过比较内存占用来确定bigkey。</li><li>Redis模块：使用第三方模块如Redis内存分析器(Redis Memory Analyzer)等进行检测，可以更加高效地发现bigkey。</li></ol><p>需要注意的是，判断bigkey的阈值大小应根据实际情况进行设定。如果一个key的内存占用量远远大于其他key，可能就需要将它视为bigkey进行处理。一般而言，当一个key的占用内存超过几MB时，就应该考虑是否需要对其进行优化。</p><h3 id="如何调优" tabindex="-1"><a class="header-anchor" href="#如何调优" aria-hidden="true">#</a> 如何调优</h3><p>为了优化 Redis 服务中的 bigkey，可以采取以下几个方面的调优：</p><ol><li>发现 bigkey：可以使用 Redis 命令 <code>redis-cli --bigkeys</code> 来检测 bigkey，并且可以根据结果对 key 进行分析和处理。</li><li>优化数据结构：将 Redis 中的数据结构调整为适合的数据结构，比如将 <code>list</code> 转换成 <code>set</code>、<code>hash</code> 或 <code>zset</code> 等。</li><li>分片数据：如果单个 key 的数据量过大，可以考虑对 key 进行分片处理，将一个大的 key 拆分成多个小的 key，然后在代码层面对它们进行合并。</li><li>定期清理过期 key：清理过期 key 可以减少 Redis 占用的内存空间，从而降低 bigkey 的风险。</li><li>控制单次操作的数据量：使用 Redis 的 <code>pipeline</code> 命令可以将多个 Redis 操作一次性发送给 Redis 服务器，从而减少网络传输的开销，但是一次性发送的数据也不能太大，应该控制在一定范围内，避免出现 bigkey 的情况。</li><li>扩容集群：如果 Redis 服务中出现了过多的 bigkey，可以考虑扩容 Redis 集群，将数据分散到多个节点上，从而降低单个节点的内存使用压力。</li></ol><p>综上所述，对于 Redis 服务中的 bigkey，可以通过发现、优化数据结构、分片数据、清理过期 key、控制单次操作的数据量和扩容集群等方式来进行生产调优。</p>`,26),o=[a];function r(y,l){return i(),d("div",null,o)}const h=e(c,[["render",r],["__file","BigKey.html.vue"]]);export{h as default};
