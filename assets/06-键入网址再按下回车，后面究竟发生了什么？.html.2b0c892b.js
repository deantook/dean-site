import{_ as o}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as s,c as i,a as e,b as a,d as p,e as n,r as l}from"./app.4816587a.js";const c={},r=n('<h1 id="键入网址再按下回车-后面究竟发生了什么" tabindex="-1"><a class="header-anchor" href="#键入网址再按下回车-后面究竟发生了什么" aria-hidden="true">#</a> 键入网址再按下回车，后面究竟发生了什么？</h1><h2 id="使用-ip-地址访问-web-服务器" tabindex="-1"><a class="header-anchor" href="#使用-ip-地址访问-web-服务器" aria-hidden="true">#</a> 使用 IP 地址访问 Web 服务器</h2><p>在浏览器的地址栏里直接输入 IP 地址「127.0.0.1」，而 Web 服务器的默认端口是 80，所以浏览器就要依照 TCP 协议的规范，使用「三次握手」建立与 Web 服务器的连接。</p><p>浏览器使用的端口是 52085，服务器使用的端口是 80，经过 SYN、SYN/ACK、ACK 的三个包之后，浏览器与服务器的 TCP 连接就建立起来了。</p><p>有了可靠的 TCP 连接通道后，HTTP 协议就可以开始工作了。于是，浏览器按照 HTTP 协议规定的格式，通过 TCP 发送了一个「GET / HTTP/1.1」请求报文，产生了第四个包。</p><p>随后，Web 服务器回复了第五个包，在 TCP 协议层面确认：「刚才的报文我已经收到了」，不过这个 TCP 包 HTTP 协议是看不见的。</p><p>Web 服务器收到报文后在内部就要处理这个请求。同样也是依据 HTTP 协议的规定，解析报文，看看浏览器发送这个请求想要干什么。</p><p>它一看，原来是要求获取根目录下的默认文件，好吧，那我就从磁盘上把那个文件全读出来，再拼成符合 HTTP 格式的报文，发回去吧，此时产生了第六个包，底层走的还是 TCP 协议。</p><p>同样的，浏览器也要给服务器回复一个 TCP 的 ACK 确认，「你的响应报文收到了，多谢」，即第七个包。</p><p>这时浏览器就收到了响应数据，但里面是什么呢？所以也要解析报文。一看，服务器给我的是个 HTML 文件，好，那我就调用排版引擎、JavaScript 引擎等等处理一下，然后在浏览器窗口里展现出了欢迎页面。</p><p>这之后还有两个来回，共四个包，重复了相同的步骤。这是浏览器自动请求了作为网站图标的「favicon.ico」文件，与我们输入的网址无关。</p><p>至此，「键入网址再按下回车」的全过程就结束了。</p><p>图里 TCP 关闭连接的「四次挥手」在抓包里没有出现，这是因为 HTTP/1.1 长连接特性，默认不会立即关闭连接。</p><img src="http://dean-imgsubmit.oss-cn-beijing.aliyuncs.com/img/8a5bddd3d8046daf7032c7d60a3d1a19.png" alt="img" style="zoom:25%;"><p>再简要叙述一下这次最简单的浏览器 HTTP 请求过程：</p><ul><li>浏览器从地址栏的输入中获得服务器的 IP 地址和端口号</li><li>浏览器用 TCP 的三次握手与服务器建立连接</li><li>浏览器向服务器发送拼好的报文</li><li>服务器收到报文后处理请求，同样拼好报文再发给浏览器</li><li>浏览器解析报文，渲染输出页面</li></ul><h2 id="使用域名访问-web-服务器" tabindex="-1"><a class="header-anchor" href="#使用域名访问-web-服务器" aria-hidden="true">#</a> 使用域名访问 Web 服务器</h2><p>把地址栏的输入改成 localhost，重复 Wireshark 抓包过程，你会发现，好像没有什么不同，浏览器上同样显示出了欢迎界面，抓到的包也同样是 11 个：先是三次握手，然后是两次 HTTP 传输。</p><p>这里就出现了一个问题：浏览器是如何从网址里知道 localhost 的 IP 地址就是「127.0.0.1」的呢？</p><p>浏览器看到了网址里的 localhost ，发现它不是数字形式的 IP 地址，那就肯定是域名了，于是就会发起域名解析动作，通过访问一系列的域名解析服务器，试图把这个域名翻译成 TCP/IP 协议里的 IP 地址。</p><p>不过因为域名解析的全过程实在是太复杂了，如果每一个域名都要大费周折地去网上查一下，那我们上网肯定会慢得受不了。</p><p>所以，在域名解析的过程中会有多级的缓存，浏览器首先看一下自己的缓存里有没有，如果没有就向操作系统的缓存要，还没有就检查本机域名解析文件 hosts，在 Windows 中为 C:\\WINDOWS\\system32\\drivers\\etc\\hosts」。</p><p>刚好，里面有一行映射关系「127.0.0.1 localhost」，于是浏览器就知道了域名对应的 IP 地址，就可以愉快地建立 TCP 连接发送 HTTP 请求了。</p><img src="http://dean-imgsubmit.oss-cn-beijing.aliyuncs.com/img/5717c967b8d46e5ba438e1d8ed605a1b.png" alt="img" style="zoom:25%;"><h2 id="真实的网络世界" tabindex="-1"><a class="header-anchor" href="#真实的网络世界" aria-hidden="true">#</a> 真实的网络世界</h2><p>真实的互联网世界要比这两个场景要复杂的多</p><img src="https://static001.geekbang.org/resource/image/df/6d/df4696154fc8837e33117d8d6ab1776d.png" alt="img" style="zoom:25%;"><p>如果你用的是电脑台式机，那么你可能会使用带水晶头的双绞线连上网口，由交换机接入固定网络。如果你用的是手机、平板电脑，那么你可能会通过蜂窝网络、WiFi，由电信基站、无线热点接入移动网络。</p><p>接入网络的同时，网络运行商会给你的设备分配一个 IP 地址，这个地址可能是静态分配的，也可能是动态分配的。静态 IP 就始终不变，而动态 IP 可能你下次上网就变了。</p>',29),d={href:"http://www.apple.com",target:"_blank",rel:"noopener noreferrer"},_=e("p",null,"互联网上还有另外一个重要的角色 CDN，它也会在 DNS 的解析过程中「插上一脚」。DNS 解析可能会给出 CDN 服务器的 IP 地址，这样你拿到的就会是 CDN 服务器而不是目标网站的实际地址。",-1),h=e("p",null,"因为 CDN 会缓存网站的大部分资源，比如图片、CSS 样式表，所以有的 HTTP 请求就不需要再发到 Apple，CDN 就可以直接响应你的请求，把数据发给你。",-1),P=e("p",null,"由 PHP、Java 等后台服务动态生成的页面属于「动态资源」，CDN 无法缓存，只能从目标网站获取。于是你发出的 HTTP 请求就要开始在互联网上的「漫长跋涉」，经过无数的路由器、网关、代理，最后到达目的地。",-1),T=e("p",null,"负载均衡设备会先访问系统里的缓存服务器，通常有 memory 级缓存 Redis 和 disk 级缓存 Varnish，它们的作用与 CDN 类似，不过是工作在内部网络里，把最频繁访问的数据缓存几秒钟或几分钟，减轻后端应用服务器的压力。",-1),m=e("p",null,"如果缓存服务器里也没有，那么负载均衡设备就要把请求转发给应用服务器了。这里就是各种开发框架大显神通的地方了，例如 Java 的 Tomcat/Netty/Jetty，Python 的 Django，还有 PHP、Node.js、Golang 等等。它们又会再访问后面的 MySQL、PostgreSQL、MongoDB 等数据库服务，实现用户登录、商品查询、购物下单、扣款支付等业务操作，然后把执行的结果返回给负载均衡设备，同时也可能给缓存服务器里也放一份。",-1),b=e("p",null,"应用服务器的输出到了负载均衡设备这里，请求的处理就算是完成了，就要按照原路再走回去，还是要经过许多的路由器、网关、代理。如果这个资源允许缓存，那么经过 CDN 的时候它也会做缓存，这样下次同样的请求就不会到达源站了。",-1),C=e("p",null,"最后网站的响应数据回到了你的设备，它可能是 HTML、JSON、图片或者其他格式的数据，需要由浏览器解析处理才能显示出来，如果数据里面还有超链接，指向别的资源，那么就又要重走一遍整个流程，直到所有的资源都下载完。",-1);function N(g,u){const t=l("ExternalLinkIcon");return s(),i("div",null,[r,e("p",null,[a("假设你要访问的是 Apple 网站，显然你是不知道它的真实 IP 地址的，在浏览器里只能使用域名「"),e("a",d,[a("www.apple.com"),p(t)]),a("」访问，那么接下来要做的必然是域名解析。这就要用 DNS 协议开始从操作系统、本地 DNS、根 DNS、顶级 DNS、权威 DNS 的层层解析，当然这中间有缓存，可能不会费太多时间就能拿到结果。")]),_,h,P,T,m,b,C])}const S=o(c,[["render",N],["__file","06-键入网址再按下回车，后面究竟发生了什么？.html.vue"]]);export{S as default};
