import{_ as a}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as e,c as i,d as r}from"./app.43a82284.js";const h={},d=r('<h1 id="缓存双写一致性问题" tabindex="-1"><a class="header-anchor" href="#缓存双写一致性问题" aria-hidden="true">#</a> 缓存双写一致性问题</h1><p>缓存双写一致性问题是指当系统中存在多级缓存时，在缓存数据更新时，可能会出现不同级别缓存数据不一致的情况。这种情况下，缓存数据更新了，但是下一次查询时，由于缓存数据不一致，导致从缓存读取的数据是错误的。</p><p>例如，在一个系统中，存在两级缓存：本地缓存和远程缓存。当一个数据在本地缓存中被更新时，远程缓存中的相应数据也需要更新，否则会出现缓存数据不一致的情况。但是，如果更新本地缓存和远程缓存的操作不是原子性的，可能会导致远程缓存中的数据没有被更新，从而导致缓存数据不一致的问题。</p><p>缓存双写一致性问题的解决方法包括：</p><ol><li>强制更新远程缓存：在更新本地缓存后，立即更新远程缓存。这样可以保证缓存数据的一致性，但会增加系统开销，降低性能。</li><li>延迟更新远程缓存：将远程缓存的更新延迟一段时间，等到本地缓存中的数据被使用时再更新远程缓存。这种方法可以减少系统开销，但可能会导致一段时间内的缓存数据不一致。</li><li>使用分布式锁：在更新缓存时，使用分布式锁来确保更新操作的原子性。这种方法可以保证缓存数据的一致性，但会增加系统开销，降低性能。</li></ol><h2 id="读写缓存" tabindex="-1"><a class="header-anchor" href="#读写缓存" aria-hidden="true">#</a> 读写缓存</h2><h3 id="同步直写策略" tabindex="-1"><a class="header-anchor" href="#同步直写策略" aria-hidden="true">#</a> 同步直写策略</h3><p>同步直写（Synchronous Write-Through）是一种缓存更新策略，用于解决缓存双写一致性问题。</p><p>在同步直写策略下，每次数据写操作会同时更新缓存和数据库。具体来说，当发生写操作时，首先将数据写入缓存，然后再将数据写入数据库。只有当数据库确认数据写入成功后，才返回操作成功。</p><p>这种策略确保了缓存和数据库的一致性。但是，由于每次写操作都需要等待数据库的确认，因此它的性能较低，可能会导致系统响应时间变慢。同时，如果缓存中的数据过多，会占用大量内存资源，导致性能下降。</p><p>因此，同步直写策略只适用于数据量较小、对数据一致性要求较高、写操作不频繁的场景。对于数据量较大、写操作频繁的场景，可以采用其他更新策略，如异步写或缓存失效等。</p><h3 id="异步缓写策略" tabindex="-1"><a class="header-anchor" href="#异步缓写策略" aria-hidden="true">#</a> 异步缓写策略</h3><p>异步缓写策略是一种缓存双写一致性问题的解决方案。在这种策略下，写入请求首先被写入到缓存中，并立即返回成功响应，同时异步地将数据写入到持久化存储中。</p><p>异步缓写策略相对于同步直写策略来说，具有更好的性能和可伸缩性，因为写入请求不需要等待数据写入持久化存储之后才返回成功响应。但是，由于数据可能会在缓存中被写入，而在异步写入到持久化存储之前就发生故障，所以可能会存在一段时间的数据不一致性。</p><p>为了避免这种情况，通常会采用一些措施，如在缓存中写入数据时使用持久化的方式，以及在数据写入持久化存储之前将其存储在一个内存队列中，以确保数据不会在丢失。此外，还可以在写入缓存和写入持久化存储之间添加一层队列，以确保写入请求的顺序。</p><h3 id="双检加锁策略" tabindex="-1"><a class="header-anchor" href="#双检加锁策略" aria-hidden="true">#</a> 双检加锁策略</h3><p>双检加锁策略是一种解决并发编程中线程安全问题的方法，它结合了懒加载和线程同步的优势，既能保证只有在需要的时候才会创建对象，又能保证线程安全。</p><p>在实现过程中，需要先检查对象是否已经创建，如果没有，再加锁创建对象。同时为了提高效率，可以再加一个判断，如果对象已经创建，直接返回已有的对象，避免重复创建。这样既能保证线程安全，又能保证效率。因此，双检加锁策略通常被广泛应用于单例模式的实现。</p><h2 id="缓存双写一致性的更新策略" tabindex="-1"><a class="header-anchor" href="#缓存双写一致性的更新策略" aria-hidden="true">#</a> 缓存双写一致性的更新策略</h2><h3 id="先更新数据库-再更新缓存" tabindex="-1"><a class="header-anchor" href="#先更新数据库-再更新缓存" aria-hidden="true">#</a> 先更新数据库,再更新缓存</h3><ul><li>异常情况一：更新mysql后，redis因为某些原因更新失败。</li><li>异常情况二：多线程更新，在事务的影响下，redis和mysql最终数据不一致</li></ul><h3 id="先更新缓存-再更新数据库" tabindex="-1"><a class="header-anchor" href="#先更新缓存-再更新数据库" aria-hidden="true">#</a> 先更新缓存,再更新数据库</h3><p>多线程更新，在事务的影响下，redis和mysql最终数据不一致</p><h3 id="先删除缓存-再更新数据库" tabindex="-1"><a class="header-anchor" href="#先删除缓存-再更新数据库" aria-hidden="true">#</a> 先删除缓存，再更新数据库</h3><ul><li>请求A进行写操作，删除redis缓存后，工作正在进行中，更新mysql......A还么有彻底更新完mysql，还没commit</li><li>请求B开工查询，查询redis发现缓存不存在(被A从redis中删除了)</li><li>请求B继续，去数据库查询得到了mysql中的旧值(A还没有更新完)</li><li>请求B将旧值写回redis缓存</li><li>请求A将新值写入mysql数据库</li></ul><p>如果数据库更新失败或超时或返回不及时，导致B线程请求访问缓存时发现redis里面没数据，缓存缺失，B再去读取mysql时，从数据库中读取到旧值，还写回redis，导致A白干了</p><h4 id="延时双删" tabindex="-1"><a class="header-anchor" href="#延时双删" aria-hidden="true">#</a> 延时双删</h4>',27),l=[d];function s(n,t){return e(),i("div",null,l)}const p=a(h,[["render",s],["__file","缓存双写一致性.html.vue"]]);export{p as default};
