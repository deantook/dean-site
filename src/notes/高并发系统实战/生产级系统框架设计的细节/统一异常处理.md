# 统一异常处理

在实际的开发中，有些程序会抛出各种各样的异常。比如我们访问 spring 项目中一个不存在的地址，则会返回如下信息

```
{
    "timestamp": "2023-04-07T15:27:44.512+00:00",
    "status": 404,
    "error": "Not Found",
    "path": "/hello"
}
```

如果因为程序产生异常，则会返回如下信息

```
{
    "timestamp": "2023-04-07T15:31:20.069+00:00",
    "status": 500,
    "error": "Internal Server Error",
    "path": "/hello"
}
```

Spring Boot 的这种默认的异常处理机制对用户并不友好。在前后端分离的系统中，这种返回的信息很难捕获和处理。在企业级系统中，有必要在框架层进行统一异常处理封装，如果不进行统一的封装，杂乱无章的信息会导致用户体验较差，每个前端开发人员都有自己的处理异常的习惯，会导致前端系统成为屎山。另外，不规范的异常封装也会对定位和排查问题带来一定的难度。

## 使用@RestControllerAdvice注解进行统一的异常处理

### 自定义异常类

1.自定义基础异常类

```java
@Getter
public class BaseException extends RuntimeException {
    private static final long serialVersionUID = 1L;
    private String module;
    private Integer code;
    private Object[] args;
    private String defaultMessage;

    public BaseException(String module, Integer code, Object[] args, String defaultMessage) {
        this.module = module;
        this.code = code;
        this.args = args;
        this.defaultMessage = defaultMessage;
    }

    public BaseException(String module, Integer code, Object[] args) {
        this(module, code, args, null);
    }

    public BaseException(String module, String defaultMessage) {
        this(module, null, null, defaultMessage);
    }

    public BaseException(Integer code, Object[] args) {
        this(null, code, args, null);
    }

    public BaseException(String defaultMessage) {
        this(null, null, null, defaultMessage);
    }

    @Override
    public String getMessage() {
        return defaultMessage;
    }
}
```

2.自定义业务异常类

```java
@AllArgsConstructor
@Getter
public class ServiceException extends RuntimeException{
    private static final long serialVersionUID =1L;
    private Integer code;
    private String message;

    @Override
    public String getMessage(){
        return message;
    }
}
```

### 捕获全局异常并进行统一处理

```java
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler
    public IResponse baseException(BaseException e){
        return BaseResponse.failure(e.getMessage());
    }

}
```





