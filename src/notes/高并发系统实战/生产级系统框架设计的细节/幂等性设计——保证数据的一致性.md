# 幂等性设计——保证数据的一致性

先看这样一个场景：用户在电商平台购物，看到自己心仪的商品，于是将其加入购物车，之后进入购物车下单结算。这时，由于网络不畅，用户在点击“提交订单” 按钮时卡住了，用户以为没提交成功，就又点击了一次“提交订单”按钮。最终，订单系统给该用户生成了两个订单，其实之前那个订单己经生成成功了。

这就是一个典型的幂等性问题。由于下单接口没有做好幂等性设计，导致用户进行两次同样的下单操作，系统给用户创建了两个订单。

## 什么是幂等性

所谓幂等性是指，用户对于同一个操作发起一次请求或多次请求，得到的结果都是一样的，不会因为请求了多次而出现异常现象。

例如，在支付时，用户点击了两次“立即支付”按钮，发生了重复支付。最终，用户发现被扣了两次款，支付系统也生成了两次支付记录，如下图所示，这就是一点非幂等的场景

![image-20230328205156326](http://dean-imgsubmit.oss-cn-beijing.aliyuncs.com/note/image-20230328205156326.png)

### 需要幂等性的场景

幂等性主要用在重复请求上，有如下几种场景：

- 用户多次请求，比如重复点击页面上的按钮。
- 网络异常，由于网络原因导致在一定时间内末返回调用成功的信息，触发了框架层的重试机制。
- 页面回退后再次提交的动作。
- 程序上的重试机制一一对于未及时响应的请求发起重试操作。

### 数据库操作的幂等性分析

数据库的上层业务操作分为 CRUD（即新增、读取、更新、删除4个动作）。

新增：如果自增主键唯一，，则数据库中会生成多条相同记录，不具备幂等性，如：

```sql
INSERT into (id, name, age, balance) VALUES (1,'test',18,100);
```

读取：无论请求多少次，读取的结果都是一样的，所以读取是天然幂等的，如：

```sql
Select name, age, balance FROM user WHERE id =1;
```

更新：条件语句中带有计算型的更新是非幂等的；反之，则是天然幂等的，如：

```sql
# 非幂等
UPDATE user SET balance = balance + 10 WHERE id = 1;
# 幂等
UPDATE user SET balance = 200 WHERE id =1;
```

删除：无论删除多少次，结果都是一样的，所以删除动作是天然幂等的，如：

```sql
DELETE FROM user WHERE id = 1；
```

可以看出，读取和删除是天然幂等的，无论执行多少次请求，最终的结果都是一样的。从这里很容易能联想到 RESTful规范中的 HTTP 请求方法：POST(C)、GET (R)、PUT(U)、DELETE (D)。

## 如何保证接口的幂等性

保证接口的幂等性通常有以下几种方式： 

- 唯一标识符：使用唯一标识符来标识每个请求，例如使用 UUID 或者生成的唯一 ID。 
- 版本号：在请求中包含版本号，以确保相同的请求在不同的版本下也具有相同的结果。 
- 检查状态：在进行更新操作前，先检查资源的状态，以确保只有在特定条件下才进行更新。 
- 重试机制：在请求失败时，可以使用重试机制来确保请求最终成功。 
- 幂等性标识符：在请求中包含幂等性标识符，以确保相同的请求只会被处理一次，而重复请求会被忽略。 
- 事务控制：使用事务控制来确保相同的请求只会被处理一次，而重复请求会被忽略。
- 分布式锁：在分布式的场景下，使用分布式锁来阻止重复请求。

下面采用两种方式说明如何防止前面用户重复提交的异常情况。

### 利用全局唯一 ID 防止重复提交

在向数据库新增一条记录时，有时会出现错误信息 “result in duplicate entry tor key primary”，原因是插入了相同 ID的信息。

利用数据库的主键唯一特性，可以解决重复提交问题：对于相同 ID 的信息，数据库会抛出异常这样新增数据的请求会失败。现在已经知道方案了，那么这个 ID 该如何和系统进行绑定呢？下面来看一下具体的落地流程。

1. 搭建一个生成全局唯一 ID 的服务。建议加入一些业务信息到该服务中，例如，在生成的订单 ID 中可以包含业务信息中的订单元素（如“OD”2021122620005600001）。该全局唯一 ID 服务可以参考雪花算法 SnowFlow 进行搭建。
2. 在订单确定页面中，调用全局唯一 ID 服务生成订单号。
3. 在提交订单时带上订单号，请求到达订单系统的下单接口。
4. 将数据库订单表 ID 和订单号进行映射，将订单号作为订单表的 ID。
5. 订单系统在创建订单信息时，订单号使用前端传过来的订单号，然后直接将该订单信息插入订单库中。
6. 如票订单写入成功，则是第一次提交，返回下单成动：如果很 ID 许突信息，则是重复提交，在订单表中只保留之前的记录，不会写入相同的新记录。

> 在报“订单重复提交” 错误时，不要向容户端抛出错误信息，因为重复提交的订单不一定全部失败。如果给用户展示错误，则用户可能还会提交订单，这会使得用户体验不是很好。可以直接向用户展示下单成功。

### 利用 Token + Redis 机制防止重复提交

再来看看另一个常用的保证幂等性的方案一使用 Token + Redis 机制防止重复提交。下面依然以订单系统的下单模块来讲解。

1. 订单系统提供一个发放 Token 的接口。这个 Token 是一个防重令牌，即一串唯一字符串 (可以使用 UUID 算法生成）。
2. 在订单确认页”中调用获取 Token 的接口，该接口向订单确认页返回 Token，同时将此 Token 写入 Redis 缓存中，并依据实际业务对其设置一定的有效期。
3. 用户在订单确认页中点击 “提交订单”按钮时，将第 2 步获取的 Token 以参数或者请求头的形式封装进订单信息中，然后请求订单系统的下单接口。
4. 下单接口在收到提交下单的请求后，首先判断在 Redis 中是否存在当前传入的 Token。
5. 利用数据库的主键唯一特性和 Token 机制来避免重复提交，是一种比较常用的接口幂等性方案。对于重复提交的场景，需要依据业务进行分析，分析当前场景是否具备幂等性，如果不具有幕等性，则需要进行幂等性设计。